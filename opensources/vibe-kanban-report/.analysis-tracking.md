---
stepsCompleted: [1, 2, 3]
completed: true
projectName: "vibe-kanban"
projectUrl: "https://github.com/BloopAI/vibe-kanban"
codebaseRef: "/home/hieutt50/projects/awesome-agentic-solutions/vibe-kanban/"
started: "2025-12-30"
lastStep: "Report Generation"
analysisCompleted: "2025-12-30"
reportsGenerated: "2025-12-30"
---

# Analysis Tracking: vibe-kanban

This file tracks the progress of the opensource codebase analysis workflow.

## Project Information

- **Project Name**: vibe-kanban
- **Project URL**: https://github.com/BloopAI/vibe-kanban
- **Codebase Reference**: /home/hieutt50/projects/awesome-agentic-solutions/vibe-kanban/
- **Started**: 2025-12-30
- **Status**: Complete

## Analysis Progress

- [x] Step 1: Initialization (inputs gathered, workspace created)
- [x] Step 2: Codebase Analysis
- [x] Step 3: Report Generation

## Workflow Complete

**Reports Generated:**
- `overview.md` - Quick summary
- `detailed-report.md` - Comprehensive analysis

**Completion Date**: 2025-12-30

---

## Analysis Findings

### Project Metadata

- **Stars**: 8.6k
- **Forks**: 814
- **Watchers**: 55
- **Contributors**: 33
- **Open Issues**: 106
- **Latest Release**: v0.0.143 (Dec 29, 2025)
- **License**: Apache-2.0
- **Primary Language**: Rust (57.9%)
- **Description**: "Get 10X more out of Claude Code, Codex or any coding agent"

### Technology Stack

**Programming Languages (by tracked code bytes):**
- Rust: 44.75% (backend + tooling)
- TypeScript (TSX): 23.56% (React UI)
- JSON: 11.82% (configs, SQLx cache)
- TypeScript: 6.88%
- YAML: 6.10% (CI + compose)
- MDX: 2.00%, SQL: 1.48%, Markdown: 0.98%

**Backend (Rust Workspace):**
- Async Runtime: Tokio
- Web Framework: Axum (0.8.4)
- HTTP Middleware: tower-http (CORS, tracing, fs)
- Database: SQLx (SQLite for local, Postgres for remote)
- Serialization: serde / serde_json
- Observability: tracing, tracing-subscriber, Sentry
- HTTP Client: reqwest
- Git Integration: git2
- Type Sharing: ts-rs (generates TypeScript from Rust)
- MCP Protocol: rmcp

**Frontend (React/TypeScript):**
- Framework: React 18
- Build Tool: Vite + @vitejs/plugin-react
- Styling: Tailwind CSS + tailwindcss-animate
- State: Zustand, TanStack React Query, TanStack React Form
- Routing: react-router-dom
- i18n: i18next, react-i18next
- UI Components: Radix UI, Lexical, CodeMirror, dnd-kit, framer-motion
- Analytics: Sentry, PostHog
- Local DB: wa-sqlite (SQLite WASM)

**Build Tools & Package Managers:**
- Rust: Cargo workspace, nightly toolchain
- Node: pnpm (workspaces)
- Bundling: Vite, TypeScript

**CI/CD:**
- GitHub Actions (test, publish, pre-release, remote-deploy)
- BuildJet runners
- cargo-zigbuild for cross-compilation
- Cloudflare R2 for binary distribution
- npm publishing for npx CLI

### Architecture Analysis

**Architecture Style:** "Local-first" desktop-like web app (SPA) + embedded backend server with optional remote/cloud integrations.

**Key Patterns:**
1. **Dependency Inversion via Deployment Abstraction** - Backend routes depend on `Deployment` trait with `LocalDeployment` implementation
2. **Service Layer** - Centralized services in `services` crate (EventService, GitService, ProjectService, ContainerService)
3. **Repository-ish Model Pattern** - SQLx model modules with CRUD/find methods
4. **Middleware Model Loader** - Path params resolved into DB models via request extensions
5. **Event Streaming + JSON Patch** - Incremental updates over WebSockets using RFC6902 patches

**Module Structure:**
- `crates/server`: Axum HTTP API + route wiring + embedded frontend
- `crates/db`: SQLx SQLite service and models/migrations
- `crates/services`: Business logic services
- `crates/executors`: Agent integrations (Claude, Codex, Gemini, etc.)
- `crates/deployment` + `local-deployment`: Environment composition
- `crates/remote`: Cloud service (Postgres, S3, auth)
- `crates/utils`: Shared utilities

**Frontend State Management:**
1. Server-derived (cacheable): TanStack React Query
2. Server-derived (realtime): WebSocket JSON Patch streams
3. Client-only UI state: Zustand stores
4. Cross-cutting context: React Context providers

### Use Cases

**Main Problem Solved:** Human orchestration bottleneck in AI-assisted software development - once coding agents can write code quickly, the limiting factor becomes task planning, parallelizing work, reviewing output safely, and integrating changes.

**Primary Use Cases:**
1. Run coding agents against scoped tasks (parallel or sequential), then review outputs
2. Safely isolate agent work using git worktrees + per-attempt branches
3. Integrate with multiple agent CLIs (swap agents per task/profile)
4. Centralize and manage MCP server configuration
5. Tight dev loop: start dev servers, open in editor, merge/rebase/push/PR

**Target User Personas:**
1. Solo developer / indie hacker
2. Staff/tech lead orchestrating multiple workstreams
3. AI-forward product engineering team (small-mid size)
4. Platform/devtools engineer (self-hosting / remote workspace)

**Supported Coding Agents:**
- Claude Code, Amp, Gemini CLI, Codex, Opencode, CursorAgent, QwenCode, Copilot, Droid

**Deployment Contexts:**
1. Local "instant run" via NPX (default)
2. Self-hosted single-user server (remote machine)
3. Containerized deployment (Docker)
4. Hosted/remote "shared" mode (Postgres + ElectricSQL)

### Evaluation

**Strengths:**
- Strong isolation model via git worktrees (safer parallel agent runs)
- Rust backend architecture with async + clear layering
- Typed cross-language contract via ts-rs (reduces frontend/backend drift)
- Tight CI checks (lint, format, types, tests)
- Good operational ergonomics around git (handles identity defaults)
- Clear "npx-first" distribution story
- Proactive DB performance work (indexes, optimizations)
- UI-protection limits for large diffs (~2MB cap)
- Fast file search via indexing + caching
- Active upstream repo with wide agent ecosystem focus

**Weaknesses:**
- Local persistence is SQLite-based (can be limiting under high concurrency)
- Complexity from dual-mode architecture (local SQLite + remote Postgres)
- Polyglot + multi-toolchain learning curve (Rust, Node, pnpm, sqlx-cli, Docker)
- Filesystem watching on Linux has scalability issues (inotify per directory)
- File search cache "cold start" issue (empty results until warmed)
- Frontend build requires 8GB Node heap in CI
- Front-end automated tests appear minimal or absent
- GitHub issue labeling hygiene looks weak

**Performance Characteristics:**
- Best-fit: single machine / small team orchestration
- Streaming updates efficient (JSON Patch over WebSockets)
- DB query hotspots addressed via indexed migrations
- Large diffs capped to prevent UI crashes
- Watching large repos on Linux is structural bottleneck

### Alternatives

1. **Aider** - Terminal-based AI coding assistant for git repos
   - Similar: CLI-first, git-native, model flexibility
   - Different: Single-agent, no multi-agent orchestration
   - Choose when: Want one fast CLI assistant per session

2. **Continue.dev** - Open-source IDE extension for chat/autocomplete
   - Similar: Multi-model support, context plumbing
   - Different: IDE-centric, not multi-agent Kanban
   - Choose when: Want customizable Copilot-like in-editor assistant

3. **Cursor** - AI-native code editor (VS Code-based)
   - Similar: Multi-step implementation and review loops
   - Different: Single integrated product, not agent coordinator
   - Choose when: Want all-in-one AI editor experience

4. **GitHub Copilot Workspace** - Task-centric GitHub environment
   - Similar: Task-first workflow (plan, implement, validate)
   - Different: GitHub-anchored, not local multi-agent toolchain
   - Choose when: Standardized on GitHub + Copilot ecosystem

5. **OpenHands (formerly OpenDevin)** - Open-source autonomous dev agent
   - Similar: Orchestration mindset, multi-step autonomy
   - Different: Single powerful agent platform, not multi-vendor coordinator
   - Choose when: Want autonomous OSS agent for experimentation

### Code Quality Observations

- Well-organized Rust workspace with clear crate separation
- Consistent code style (rustfmt, ESLint, Prettier)
- Type-safe API contract via ts-rs code generation
- Migrations include performance optimization passes
- AGENTS.md provides clear contributor guidance
- Integration tests for git operations

### Community and Maintenance

- Active development (v0.0.143, Dec 29, 2025)
- 33 contributors
- 8.6k GitHub stars indicates strong community interest
- 106 open issues (active engagement)
- GitHub Discussions used for feature requests
- Discord community available
- Hiring indication suggests commercial backing
